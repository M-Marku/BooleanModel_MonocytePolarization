---
title: "Boolean model of monocyte polarization in TME"
output: html_notebook
author: "Malvina Marku, CRCT, Team 21"
status: under improvement
---

In this script we show all the steps Boolean modelling of a monocyte polarization network. The script is being organized in 5 main parts: \

1. Network representation of the regulatory system\
2. Boolean model (BoolNet R package)\
  - Attractor analysis;\
  - Organization of the attractor space;\
3. Attractor similarities and clustering\
4. Biological information from attractor categorization\
5. Perturbation and robustness analysis\

A short description of the biological background of the network will be inserted soon.\

Some libraries used for running all the commands in this script 
```{r}
library(BoolNet)
library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
library(magrittr)
library(ggplot2)
library(reshape2)
library(proxy)
library(plot.matrix)
library(clValid)
library(pheatmap)
library(cluster)
```

# <font size="4"> __1. Network representation of the regulatory system__ </font>

The next commands upload the Boolean rules and construct the interaction network between components. It should be noted though that the network reprentation does not show the inhibitory relatioships.

```{r}
mono_rules <- loadNetwork("/media/malvina/MALMAR/Malvina/Monocyte_CLL_BooleanModel/Plot_Attractors/rules_modified.txt")
plotNetworkWiring(mono_rules)  # to plot the network
```

# <font size="4"> __2. Boolean model__ </font>
In a Boolean model, each component in the netowrk can have only 2 possible states: 0 (OFF, low expression) and 1 (ON, high expression). To get the long term behaviour of the system, BoolNet applies different methods, consisting on: \

- different initial states: we can choose between considering all possible initial states ($2^N$, $N$ - number of components in the system), or start from a pre-determined initial state (starting from a certain initial state, or a fraction of $2^N$ initial states). \
- different updating methods: there are 2 main updating methods, depending on the updating algorithms: synchronous and asynchronous (random order asynchronous, general asynchronous and deterministic asynchronous). The main difference between the two methods consist on the updating orders of each component in each time step (discrete): in the synchronous method all the components are updated simultaneously in each time step, while in the asynchronous methods the updating orders of each components are chosen randomly or pre-determined by a characteristic updating time. \

It is important to note that: \

1. Since the state space is finite, eventually the system will return to (at least) one of it's states called attractor, which can be a single state (fixed point) or a set of oscillating states (limit cycle). Once the system reaches an attractor, it will stay in it when $t -> \infty$. \
2. The fixed points of the system are time independent (ie. the updating methos will not affect the fixed points, but only the limit cycles). \
3. The set of initial states that lead to an attractor define the _basin of attraction_ (in BoolNet this can be calculated for network with $N<29$). \
4. The network of all the possible states and their transition define the _state transition graph_. The attractors can be identified directly from the state transition graph (not recommended if $N>20$). \

Here we study only the fixed points: `maxAttractorLength = 1`
```{r}
# Method 1: (N<29) get all the possible attractors, starting from every possible initial condition
# attr <- getAttractors(mono_rules, type = "synchronous", returnTable = T) # choose between synchronous or asynchronous

# For more than 29 genes, choose sat.restricted instead
attr <- getAttractors(mono_rules, method = "sat.restricted",maxAttractorLength = 1)

# Exhaustive computation, skip if N>15
#plotStateGraph(attr, highlightAttractors = T, colorBasins = T, drawLegend = F, drawLabels = F, piecewise = F)

# Not possible for N>29
basinValues <- sapply(attr$attractors[1:length(attr$attractors)], function(attractor){
  attractor$basinSize })
basinTable <- tibble(Attr = paste0('Attr',1:length(attr$attractors)), basinSize = basinValues)
```

In the lines below, we extract information about the attractors and re-organize the attractor space according to the output components' states (in our case: M0, M1, M2 and TAM). This organization helps to identify the possible phenotypes.
```{r}
# Organize the attractors' space
# Here we organize the attractor space according to the expression of M0, M1, M2, and TAM phenotypes
attr_matrix <- plotAttractors(attr, borderColor = NA)
attr_frame <- as_tibble(attr_matrix$`1`, rownames = "gene") #creates the attractors' frame
attr_frame_t <- attr_frame %>%
  rownames_to_column() %>%
  gather(var, value, -rowname) %>%
  spread(rowname, value)
colnames(attr_frame_t) <- attr_frame_t[nrow(attr_frame_t),]
attr_frame_t <- attr_frame_t[-nrow(attr_frame_t),]

colnames(attr_frame_t)[1] <- "Attr"

attr_frame_t$Attr <- sapply(attr_frame_t$Attr, function(attr) {
  str_split(attr,'\\.')[[1]][[1]] })

attr_frame_t_numeric <- attr_frame_t %>% select(-1) %>% mutate_all(funs(as.numeric(.)))
attr_frame_t_bool <- attr_frame_t_numeric %>% mutate_all(funs(as.logical(.)))
attr_frame_t_bool$Attr <- attr_frame_t$Attr
attr_frame_t_bool %<>% select(Attr,everything())

attr_frame_t_sorted_by_pheno <- attr_frame_t_bool %>% arrange(M1, M2, TAM)

attr_frame_t_sorted_with_basinSize <- inner_join(basinTable, attr_frame_t_sorted_by_pheno, by = "Attr") %>% filter(!is.na(Attr))

m_0 <- attr_frame_t_sorted_with_basinSize %>% filter(!xor(M1,M2)) # criteria for obtaining a M0
m_2 <- attr_frame_t_sorted_with_basinSize %>% filter(M2 & !Attr %in% m_0$Attr) # criteria for obtaining a M1
m_1 <- attr_frame_t_sorted_with_basinSize %>% filter(M1 & !Attr %in% m_0$Attr) # criteria for obtaining a M2
tam <- attr_frame_t_sorted_with_basinSize %>% filter(TAM) # criteria for obtaining a TAM

attr_frame_t_sorted_with_basinSize[attr_frame_t_sorted_with_basinSize$Attr %in% m_0$Attr, 'phenotype'] <- "M0"
attr_frame_t_sorted_with_basinSize[attr_frame_t_sorted_with_basinSize$Attr %in% m_1$Attr, 'phenotype'] <- "M1"
attr_frame_t_sorted_with_basinSize[attr_frame_t_sorted_with_basinSize$Attr %in% m_2$Attr, 'phenotype'] <- "M2"
attr_frame_t_sorted_with_basinSize[attr_frame_t_sorted_with_basinSize$Attr %in% tam$Attr, 'phenotype'] <- "TAM"
colors <- c("purple", "blue", "yellow", "magenta")
phenotypes <- as.factor(attr_frame_t_sorted_with_basinSize$phenotype)
```

As noted above, if $N<29$ we calculate the basins of attraction for each attractor. This calculation can be important to pre-estimate the likelihood for the system being or reaching an attractor. Considering the criteria for detecting each phenotype (se lines `[99-102]`), we plot the histograms of the basins of attraction for each phenotype. \
Note: Skip if $N>29$.
```{r}
# Plot histograms of the basins of attraction
hist(m_0$basinSize, main = "M0 phenotype basin of attraction", xlab = "Basin size", labels = T, col = "purple")
png(filename = "M0_BasinOfAttr.png")

hist(m_1$basinSize, main = "M1 phenotype basin of attraction", xlab = "Basin size", labels = T, col = "blue")
png(filename = "M1_BasinOfAttr.png")

hist(m_2$basinSize, main = "M2 phenotype basin of attraction", xlab = "Basin size", labels = T, col = "yellow")
png(filename = "M2_BasinOfAttr.png")

hist(tam$basinSize, main = "TAM phenotype basin of attraction", xlab = "Basin size", labels = T, col = "yellow")
png(filename = "TAM_BasinOfAttr.png")
```

```{r}  
# Detect the phenotypes
attr_frame_t_numeric <- attr_frame_t_sorted_with_basinSize %>% select(-c(Attr, phenotype, basinSize)) %>% mutate_all(funs(as.numeric(.)))
attr_frame_matrix <- as.matrix(attr_frame_t_numeric)
rownames(attr_frame_matrix) <- attr_frame_t$Attr
emr_col <- as.matrix(rownames(attr_frame_matrix))
```

# <font size = "4"> __3. Attractor similarities and clustering__ </font>
Here we apply non-supervised methods to detect the possible phenotypes of monocyte polarization. We start by calculating the Jaccard - Needham distance, given by the definition:
Given two binary vectors $X, Y \in \Omega$ and $S_{ij} (i,j\in \{0,1\})$ be the number of occurrences of matches with $i \in X$ and $j\in Y$ at the corresponding positions, the *_Jaccard-Needham_* measure is defines as \
$$ 
(similarity) \hspace{10mm} S(X,Y) = \frac {S_{XY}} {S_{XY}+S_{X\bar{Y}}+S_{\bar{X}Y}}
$$
$$
(dissimilarity) \hspace{10mm} D(X,Y) = \frac {S_{X\bar{Y}}+S_{\bar{X}Y}} {S_{XY}+S_{X\bar{Y}}+S_{\bar{X}Y}}
$$
$$
D(\bar{I}, \bar{I})=0
$$
where , $I$ is the indetity matrix, and $\bar{X}, \bar{Y}$ are the complement vectors of $X,Y$. \
To calculate the Jaccard - Needham distance the `dist` function is being used, choosing `Jaccard` as distance method.
```{r}
jac_dist <- dist(attr_frame_matrix, attr_frame_matrix, method = "Jaccard")
```

The matrix of the distances between $572$ attractors we obtained following the commands above is as follows
```{r}
m <- matrix(jac_dist, nrow = length(attr$attractors))
plot(m, breaks = NULL, col = hcl.colors(20, palette = "PRGn"), border = NA, key = list(side = 4, cex.axis = 1.75), main = "Jaccard-Needham distance matrix")
```

Next, we plot the heatmap of the distance matrix. What we expect to find is that attractors corresponding the same phenotype will have the smallest distance amongst them. Consenquently, we expect to detect a cluster for each phenotype (4 clusters)
```{r}
matrica <- as.matrix(m)
cn <- paste("Attr", 1:length(attr$attractors), sep = "")
rn <- paste("Attr", 1:length(attr$attractors), sep = "")
colnames(matrica) <- cn
rownames(matrica) <- rn
h <- pheatmap(matrica, border = NA, col = hcl.colors(20, palette = "PRGn"), cutree_rows = 3, show_colnames = T,show_rownames = F, fontsize = 3)
```

To have a deeper look at the attrators corresponding to each cluster, we plot the clusters separately, running the following commands
```{r}
S <- sort(cutree(h$tree_row, k = 3))
Clust_frame <- melt(lapply(split(S, names(S)), unname))
colnames(Clust_frame) <- c("Cluster", "Attr")
Clust_frame_attr <- merge(Clust_frame, attr_frame_t, by = intersect(names(Clust_frame), names(attr_frame_t)))

Clust1 <- Clust_frame_attr %>% filter(Cluster == 1)
plot(as.matrix(Clust1[3:length(mono_rules$genes)]), main = "Cluster 1", xlab = "Genes", ylab = "Attractors")
Clust2 <- Clust_frame_attr %>% filter(Cluster == 2)
plot(as.matrix(Clust2[3:length(mono_rules$genes)]), main = "Cluster 2", xlab = "Genes", ylab = "Attractors")
Clust3 <- Clust_frame_attr %>% filter(Cluster == 3)
plot(as.matrix(Clust3[3:length(mono_rules$genes)]), main = "Cluster 3", xlab = "Genes", ylab = "Attractors")
Clust4 <- Clust_frame_attr %>% filter(Cluster == 4)
plot(as.matrix(Clust4[3:length(mono_rules$genes)]), main = "Cluster 4", xlab = "Genes", ylab = "Attractors")
```

But, what is true number of clusters? Ie, what is the optimal number of cluster we detect in the distance matrix? To answer this, we apply the __elbow method__. Running the following commands, we plot of score as a function of the number of clusters $k$. The optimal number of clusters will be the value of $k$ in which we observe the "elbow".\
Basically, the algorithm will run multiple times over a loop, with an increasing number of cluster choise. 
```{r}
set.seed(333)
k.max <- 10
data <- matrica
elb <- sapply(1:k.max, function(k) {
  kmeans(data, k, nstart = 50, iter.max = 20)$tot.withinss
})
plot(1:k.max, elb, type = "b", pch = 10, frame = F, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares")
```

It is important to note that the score for each $k$ is calculated as a form of intra-cluster distance relative to inner-cluster distance. From the graph, we observe that the optimal number of clusters is 3 (`k = 3`).\
Next, we make the _silhouette plot_ of the clusters with `kmeans = 3`. The plot appears as below

```{r}
kmm <- kmeans(matrica, 3, iter.max = 20)
D <- daisy(matrica)
plot(silhouette(kmm$cluster, D), col = 1:3, border = NA, main = "Silhouette plot of 3 clusters")
```
__Reminder__: The _silhouette method_ refers to a method of interpretation and validation of consistency within clusters of data. The silhouette value is a measure of how similar an object is on its own cluster (cohesion) compared to other clusters (separation) ($s_i \in \{-1,1\}$). By definition, assuming that data has been clustered via a clustering technique, for each data point $i \in C_i$ (ie, data poit $i$ in the cluster $C_i$) let
$$
a(i) = \frac {1} {|C_i| - 1} \sum_{j\in C_i, i \neq j} {d(i,j)}
$$
be the mean distance between $i$ and all the other data points in the cluster, $d(i,j)$ is the distance between data points $i$ and $j$ in $C_i$;
$$
b(i) = \min_{k \neq i} {\frac {1} {|C_k|} \sum_{j \in C_k} {d(i,j)}}
$$
be the smallest mean distance of $i$ to all points in any other cluster, then the _silhouette value_ is defined as 
$$
s(i) = \frac {b(i) - a(i)} {\max { \{a(i), b(i) \} }}, \hspace{5mm} if \hspace{2 mm} |C_i| >1 \\
s(i) = 0, \hspace{5mm} if \hspace{2 mm} |C_i| =1 
$$
__Comment the plot here__

# <font size = "4"> __4. Biological information from attractor categorization__ </font>
Next, we plot the heatmap of the attractors and the list of network components, organized based on the criterai of obtaining M0, M1, M2 and TAM. 

```{r}
heatmap(t(attr_frame_matrix),col = c('#e41a1c', '#4daf4a'), ColSideColors = colors[phenotypes])
legend(x = "topleft", legend = c("not expressed", "expressed", "M0", "M1", "M2", "TAM"), fill = c('#e41a1c','#4daf4a',"purple", "blue", "yellow", "grey"))
attr_frame_t_sorted_melt <- melt(attr_frame_t_sorted_by_pheno, id = c("Attr")) 
```

__Probabilities equivalent to the clusters? __
Plotting the fractions of attractors representing each phenotype.
```{r}
# Calculate the M0, M1, M2 phenotype frequence according to the expressions of their characteristic proteins
m1 <- as.numeric(attr_frame_t_sorted_by_pheno$M1)
m2 <- as.numeric(attr_frame_t_sorted_by_pheno$M2)
Tam <- as.numeric(attr_frame_t_sorted_by_pheno$TAM)
m0 <- sum(m1 & m2) + length(m1) - sum(m1 | m2)
prob_m0 <- (m0)/length(m1)

prob_M1 <- (sum(m1, na.rm = T) - sum(m1 & m2))/length(m1)
prob_M2 <- (sum(m2, na.rm = T) - sum(m1 & m2))/length(m2)
Prob_TAM <- (sum(tam, na.rm = T))/length(Tam)
Prob <- c(prob_m0, prob_M1, prob_M2, Prob_TAM)
Pheno <- c('M0', 'M1', 'M2','TAM')
barplot(Prob,names.arg = Pheno,col = "#69b3a2",horiz = F, beside = T, xlab = "Phenotype", ylab = "Probability")
labels -> Prob
```


# <font size = "4"> __5. Perturbation and robustness analysis__ </font>
A biological network is assumed to be robust if small amounts of noise or perturbation won't significantly change its properties and behaviour. There are two major ways of applying random noise: (1) perturb _the current state_ or perturb _the network tructure itself_. Below we perform some of these pertubations on the monocyte polarization network.

## <font size = "4"> __5.1. Pertubations on the current state__ </font>
The function `perturbTrajectories` measures _the influence of noise that is applied to the current netowrk state_. It generates a set of initial states and creates perturbed copies of these states by randomly flipping the bits. The function calculates different measures, eg. `hamming` distance, `sensitivity` and `attractor`. \

- `measure = "hamming"` - a single state transition is performed for each initial state and perturbed copy and the __fraction of different bits__ is measured; \
- `measure = "sensitivity"` - a single state transition is performed for each initial state and perturbed copy and the __number of successor states tha differ between the original states and the pertuberd copies for a given gene__ is measured; \
- `measure = "attractor"` - measures the fraction between the attractors reached by the initial states and their perturbed copies. \

Below we perform the sensitivity analysis for all the `genes` in the network, for a number of initial states `numSamples = 1000`. 

```{r}
calculate_sensitivity <- lapply(mono_rules$genes, function (gene) {
  perturbTrajectories(mono_rules, measure = "sensitivity", numSamples = 1000, flipBits = 1, gene = gene)
})
names(calculate_sensitivity) <- mono_rules$genes
values <- sapply(calculate_sensitivity, function(gene) {gene$value})
names(values) <- mono_rules$genes
barplot(values, las = 3, main = "Sensitivity analysis")
png(filename = "SensitivityAnalysis.png")
dev.off()
```

## <font size = "4"> __5.2. Pertubations on the network itself__ </font>
The function `pertubNetwork` does not perform any simulations but returns a perturbed copy of the network that can be analysed further. The perturbation can run on: \

- `perturb = "functions"` - chooses a function of the netwrok at random and flips `maxNumBits` bits in this function (`method = "bitflip"`) or change the Boolean function completely (`method = "shuffle"`). \
- `perturb = "transitions"` - to be completed. \

In the lines below, a perturbation experiment is performed: here 100 perturbed copies of the monocyte polarization network are created and the occurrences of the original synchronous attractors are counted in the perturbed copies. \
Note 1: this simulation is similar to `perturbTrajectories, measure = "attractor"`, but instead of comparing the outcomes of different _initial states_ in the same netowrk, it compares _all attractors_ of different perturbed networks to the original network. \
Note 2: __Skip if $N>29$ genes.__

```{r}
perturbationResults <- sapply(1:100, function(i) { 
  perturbedNet <- perturbNetwork(mono_rules, perturb = "functions", method = "bitflip")
  perturbedAttrs <- getAttractors(perturbedNet, canonical = TRUE)
  attractorIndices <- sapply(attr$attractors,function(attractor1) 
  {index <- which(sapply(perturbedAttrs$attractors, function(attractor2) {identical(attractor1, attractor2)}
  ))
  if (length(index) == 0)
    NA
  else
    index })
  return(attractorIndices) })
```
Here `perturbationResults` now contains a matrix with the first 2 columns specifying the indices or the original attractors in the perturbed network (or NA if the attractor was not found) and the next 2 columns counting the numbers of states in the basin of attractio (or NA if the attractor was not found). \
Measure the total numbers of occurrences of the original attractors in the perturbed copies:

```{r}
numOccurrences <- apply(perturbationResults[seq_along(attr$attractors),,drop = FALSE], 1, function(row)sum(!is.na(row)))
# print original attractors
cat("Attractors in original network:\n")
print(attr)
# print information
cat("Number of occurrences of the original attractors", "in 10 perturbed copies of the network:\n")
for (i in 1:length(attr$attractors)) 
  
{ cat("Attractor ",i,": ",numOccurrences[i],"\n",sep = "") }

sink('analysis_output.txt', append = TRUE)
cat("Analyisis Output\n")
sink()
```


## <font size = "4"> __5.3. Indentify specific properties of the network__ </font>
In this session, we perform some simulations in order to highlight some properties of the real-world networks compared to the arbitrary (random) ones. It is supposed that attractors in the RWN are more robust to perturbations than in random networks, assuming similar structures. \
`testNetworkProperties` is a function which performs computer-intensive simulations to test specific network properties, such as: \

- `testFunction = "testAttractorRobustness"` - creates a set of `numRandomNets` random nets by perturbiting the Boolean functions on the original net; for each net it calculates the percentage of attractors that can be found in the perturbed copies (the percentage of similar attractors is higher in real-world bionets)

```{r}
attr_rob <- testNetworkProperties(mono_rules, numRandomNets = 100, testFunction = "testAttractorRobustness", 
                                  testFunctionParams = list(copies = 100, perturb = "functions"))
```

- `testFunction = "testTransitionRobustness"` - as above, but the perturbation is being performed on current states and the Hamming distance is calculated (the distance is smaller in real-world bionets)
```{r}
tran_rob <- testNetworkProperties(mono_rules, numRandomNets = 100, testFunction = "testTransitionRobustness", 
                                  testFunctionParams = list(numSamples = 100), alternative = "less")
```
